# üìÖ Week 7 ‚Äì CSIS 2260 (Operating Systems) ‚Äì Survey Week with Practice

## **Day 4 ‚Äì Processor Management & Scheduling**

### üîç Concepts

- **CPU Scheduling Goals**:
  - Maximize CPU utilization
  - Minimize waiting time
  - Provide fairness among processes
- **Common Scheduling Algorithms**:
  - **First-Come, First-Served (FCFS)** ‚Äì Non-preemptive, simple queue.
  - **Shortest Job First (SJF)** ‚Äì Runs process with the smallest CPU burst next.
  - **Round Robin (RR)** ‚Äì Preemptive, each process gets a fixed time quantum.
- **Context Switching**:
  - Saving the state of the current process and loading the state of the next process.

### üìñ Theory Notes

- **FCFS**:
  - Pros: Simple
  - Cons: Can cause ‚Äúconvoy effect‚Äù
- **SJF**:
  - Pros: Minimizes average waiting time
  - Cons: Requires knowing the CPU burst time in advance
- **RR**:
  - Pros: Fair time allocation
  - Cons: Too small quantum ‚Üí overhead; Too large quantum ‚Üí behaves like FCFS

---

### ‚úçÔ∏è Pseudocode Test (Round Robin)

```
WHILE processes remain
  SELECT next process in queue
  EXECUTE for time quantum
  IF process finished THEN remove
  ELSE add to end of queue
ENDWHILE
```

---

### üß™ Code Simulation (Python ‚Äì Class-based)

```python
from collections import deque

class Process:
    def __init__(self, pid, time):
        self.pid = pid
        self.time = time

class Scheduler:
    def __init__(self, processes, quantum):
        self.processes = processes
        self.quantum = quantum

    def run(self):
        while self.processes:
            process = self.processes.popleft()
            run_time = min(self.quantum, process.time)
            print(f"Running {process.pid} for {run_time} units.")
            if process.time <= self.quantum:
                process.time = 0
            else:
                process.time -= self.quantum
                self.processes.append(process)

def main():
    processes = deque([
        Process("P1", 5),
        Process("P2", 3),
        Process("P3", 8),
    ])
    sch = Scheduler(processes, quantum=2)
    sch.run()

if __name__ == "__main__":
    main()
```

---

### üß™ Code Simulation (JavaScript ‚Äì Class-based)

```js
class Process {
  constructor(pid, time) {
    this.pid = pid;
    this.time = time;
  }
}

class Scheduler {
  constructor(processes, quantum) {
    this.processes = processes;
    this.quantum = quantum;
  }

  run() {
    while (this.processes.length > 0) {
      const process = this.processes.shift();
      const runTime = Math.min(this.quantum, process.time);
      console.log(`Running ${process.pid} for ${runTime} units.`);
      if (process.time > this.quantum) {
        process.time -= this.quantum;
        this.processes.push(process);
      }
    }
  }
}

const processes = [
  new Process("P1", 5),
  new Process("P2", 3),
  new Process("P3", 8)
];

const scheduler = new Scheduler(processes, 2);
scheduler.run();
```

---

### üß™ Code Simulation (C# ‚Äì Class-based)

```csharp
using System;
using System.Collections.Generic;

public class Process
{
    public string Pid { get; set; }
    public int Time { get; set; }
    public Process(string pid, int time)
    {
        Pid = pid;
        Time = time;
    }
}

public class Scheduler
{
    private Queue<Process> processes;
    private int quantum;

    public Scheduler(Queue<Process> processes, int quantum)
    {
        this.processes = processes;
        this.quantum = quantum;
    }

    public void Run()
    {
        while (processes.Count > 0)
        {
            var process = processes.Dequeue();
            int runTime = Math.Min(quantum, process.Time);
            Console.WriteLine($"Running {process.Pid} for {runTime} units.");
            if (process.Time > quantum)
            {
                process.Time -= quantum;
                processes.Enqueue(process);
            }
        }
    }
}

class Program
{
    static void Main()
    {
        var processes = new Queue<Process>(new[]
        {
            new Process("P1", 5),
            new Process("P2", 3),
            new Process("P3", 8)
        });

        var scheduler = new Scheduler(processes, 2);
        scheduler.Run();
    }
}
```

---

### ‚ùì Quiz

1. Which algorithm can cause starvation and why?
2. In Round Robin, what is the impact of choosing a very small time quantum?
3. What is the ‚Äúconvoy effect‚Äù in FCFS scheduling?

---

**‚úÖ Deliverable for Day 4**

- Notes on FCFS, SJF, and RR algorithms.
- Completed pseudocode test.
- Working class-based code simulations in Python, JavaScript, and C#.
- Quiz answers recorded.

