# ðŸ’¾ Early Programming
â€“ Crash Course Computer Science #10

In this episode, I learned about how early computers were programmed and how programming evolved over time from physical hardware setups to software-based instructions.

---

## ðŸ§µ The Origins: Punched Cards

The idea of programmable machines began in the early 1800s. In 1801, **Joseph Marie Jacquard** developed a textile loom that could be programmed using **punched cards**. These punched cards encoded patterns in a physical format and made it possible to automate weaving designs. This system became a cheap, reliable, and relatively human-readable way to store information.

Later, in the 1890s, the U.S. Census Bureau used **tabulating machines** that also relied on punched cards. However, unlike Jacquardâ€™s loom, these machines were not programmable â€” they were designed only to process data, not to execute a variety of instructions.

---

## ðŸ”Œ Plugboards and Panel Programming

Eventually, **plugboards** (also known as control panels) emerged, allowing operators to physically rewire machines for different tasks. Each program required rearranging cables â€” a time-consuming and error-prone process. By the 1920s, plugboards became swappable modules, but they remained difficult to configure and demanded expert knowledge.

In 1946, the **ENIAC**, one of the first general-purpose electronic computers, still used plugboards. Reprogramming ENIAC was expensive and could take up to **three weeks** just to wire and debug a new program.

---

## ðŸ§  The Shift to Stored Programs

As electronic **memory** became more affordable and its capacity increased, computers began storing both **data** and **programs** in memory. This allowed for programs to be changed and accessed quickly â€” a revolutionary shift in computing.

The **Von Neumann architecture**, introduced in the late 1940s, proposed a single shared memory for both data and program instructions. This architecture is still used in modern computers today.

---

## ðŸ’³ Punched Cards and Paper Tapes

Even with electronic memory, in the 1950s and beyond, programs were still often **loaded into memory using punched cards**. Each program was stored as a stack of cards, and programmers would draw a **diagonal line** (called "striping") on the side of the stack to keep cards in order.

One of the largest punch-card-based programs was the **SAGE Air Defense System**, developed for the U.S. Air Force in 1955. It used **over 62,000 punched cards**, representing about **5MB** of data â€” a massive program at the time. At its peak, this project employed around **20% of the worldâ€™s programmers**.

Output could also be punched into new cards, forming a full punched-card programming and data pipeline.

Other early storage formats included **punched paper tape**, which was also used to store and load instructions.

---

## ðŸ”˜ The ALTAIR and Panel Programming

In 1975, the **Altair 8800**, a hobbyist computer, allowed programmers to use **panel programming**. This involved setting binary values using switches and confirming each instruction using buttons and indicator lights. Programming was still very low-level and time-consuming.

---

## ðŸ“œ The Need for Programming Languages

Programming early computers required deep technical expertise and was often extremely **tedious**. These challenges led to the development of **programming languages** â€” systems that allowed humans to write instructions in more readable and efficient ways. This innovation paved the way for modern software development.

---

## ðŸ§  Key Takeaways

- **Punched cards** allowed early machines to store instructions but were inflexible.
- **Plugboards** required rewiring to switch programs.
- **ENIAC** used plugboards and required days or weeks to reprogram.
- **Von Neumann architecture** introduced the stored-program concept.
- **Punch cards and tapes** were still used to load and store programs.
- The **need for easier programming** led to the rise of programming languages.

---

This episode shows how programming evolved from hardware wiring to flexible software â€” and helps me understand how far computing has come.